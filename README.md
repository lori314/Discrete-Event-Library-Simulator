# 基于离散事件模拟的图书馆管理系统 (Java OOP实践)

## 1. 项目概述

这是我在面向对象课程中，完成的一个模拟真实世界图书馆运营的复杂课程设计。

项目的核心是构建一个**基于离散事件驱动的模拟器**，该模拟器需要能够精确处理图书馆在每日开馆、闭馆以及响应用户请求（如借、还、预约图书）时的各种复杂业务逻辑和状态变迁。同时，项目配置了uml类图，可以使用starUML等软件进行查看。

这个项目是我对**面向对象分析与设计 (OOAD)** 的一次深度实践。我将图书馆中的每一个实体（用户、书籍、预约）和每一条规则（借阅限制、信用积分、预约排队），都 meticulously地抽象和实现为一套相互协作的Java类。

---

## 2. 系统核心设计与业务逻辑实现

我将整个系统架构设计为一个**事件驱动模型**，由一个中央的`Library`类作为事件处理器，来响应和处理外部输入的命令。

### **a. 核心实体与状态机设计**

*   **`User` (用户):**
    *   不仅包含基本信息，还通过其持有的`heldCopies`, `reservedCopies`, `credits`等属性，共同构成了一个复杂的**隐式状态机**。
    *   用户的权限（如能否借书、预约）完全由其当前状态动态决定。例如，信用分低于阈值或持有特定类型的书籍，都会限制其后续操作。

*   **`BookCopy` (图书复本) & `LibraryBookState`:**
    *   这是系统中最核心的**显式状态机**。每一本实体书都被抽象为一个`BookCopy`对象。
    *   其状态`currentLocation`可以在`BOOKSHELF` (书架), `APPOINTMENT_OFFICE` (预约处), `USER` (用户手中), `BORROW_RETURN_OFFICE` (借还处) 等状态之间流转。每一次流转，都由一个明确的事件触发，并记录在`movementHistory`中。

*   **`Appointment` (预约):**
    *   将一次成功的“预约-取书”过程，抽象为一个生命周期有限的`Appointment`对象。它包含了预约用户、绑定的具体图书复本、以及预约的生效和失效日期。

### **b. 关键业务流程的实现**

*   **预约与排队 (`handleOrder` & `openOrganize`):**
    *   这是系统中最复杂的业务逻辑。我设计了一个`pendingReservationsByIsbn`队列，来管理对同一种书籍（相同ISBN）的所有预约请求。
    *   在每日开馆整理 (`openOrganize`) 时，系统会触发事件，检查所有在架的书籍。若有可满足的预约，系统会严格按照**“先到先得”**的原则，为队列中的用户创建`Appointment`实例，并更新对应`BookCopy`的状态。这完美模拟了真实世界的资源分配与排队逻辑。

*   **信用积分系统 (`User.update`):**
    *   我实现了一套完整的信用积分系统。用户的信用会因为**按时还书而增加**，也会因为**预约过期未取、在阅读室过夜不还**等违约行为而减少。信用积分直接与用户的借阅和预约权限挂钩，形成了一个动态的奖惩闭环。

*   **离散事件模拟 (`open`/`close`):**
    *   系统的运行由`OPEN`和`CLOSE`这两个**时间推进事件**驱动。
    *   在每个时间点（开馆日或闭馆日），系统都会进行一次全局的“清算”，处理所有到期的`Appointment`，惩罚超期未还的用户，并将借还处的书籍整理回书架。这体现了离散事件模拟的核心思想。

---

## 3. 技术与能力总结

*   **面向对象分析与设计 (OOAD):** 展现了将一套复杂的现实世界业务规则，精确地抽象和翻译成一个健壮、可维护的软件系统的能力。
*   **状态机设计:** 熟练地为核心实体设计和实现了清晰的状态变迁逻辑。
*   **事件驱动架构:** 理解并实践了基于离散事件的系统设计模式。
*   **Java核心技术:** 深入使用了Java的集合框架 (`HashMap`, `ArrayList`) 来管理对象间的复杂关系，并利用`java.time`包进行了精确的日期计算。

---

## 4. 如何运行

*   本项目依赖于官方提供的`com.oocourse.library3`评测包。
*   将官方`.jar`包配置为项目的外部库后，通过官方提供的`Main`类即可运行。程序将从标准输入读取指令序列，并模拟图书馆的运行过程。
